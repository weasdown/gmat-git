# CubicSpline.py

"""
2019-02-14; nhatten; initial creation

@author: nhatten
"""

import autograd
import autograd.numpy as np
from autograd import grad
from autograd import jacobian

class CubicSpline(object):
    """
    Holds routines related to calculating a cubic spline
    """

    def __init__(self):
        """
        constructor
        """
        return

    def EvaluateClampedCubicSplineVectorized(self, a, b, c, d, xarray, x):
        """
        Evaluate cubic spline whose coefficients were generated by CalculateClampedCubicSplineCoefficients
        @param a Array of spline coefficients: constant coefficient
        @param b Array of spline coefficients: linear coefficient
        @param c Array of spline coefficients: quadratic coefficient
        @param d Array of spline coefficients: cubic coefficient
        @param xarray The values of the independent variable used to generate the spline as a numpy array
        @param x Value of independent variable
        @return y The splined values of the dependent variable at x
        @return dy Splined dy/dx
        @return ddy Splined d^2y/dx^2
        """        

        # calculate where we are in the spline (i.e., the value of i s.t. x[i] <= x < x[i+1], assuming all x[i+1] > x[i])

        # from https://stackoverflow.com/questions/38741718/optimal-way-for-finding-index-of-greatest-value-less-than-in-numpy-array
        s = np.size(xarray)
        i = np.minimum(xarray.searchsorted(x, 'right')-1, s-1)

        aNeeded = a[i,:]
        bNeeded = b[i,:]
        cNeeded = c[i,:]
        dNeeded = d[i,:]

        dx = x - xarray[i]

        dxdNeeded = dx * dNeeded
        threeDxdNeeded = 3.0 * dxdNeeded
        y = aNeeded + dx * (bNeeded + dx * (cNeeded + dxdNeeded))
        dy = bNeeded + dx * (2.0 * cNeeded + threeDxdNeeded)
        ddy = 2.0 * (cNeeded + threeDxdNeeded)
        return y, dy, ddy

    def CalculateClampedCubicSplineCoefficients(self, x, y, dydx0, dydxf):
        """
        Calculate constants for a clamped cubic spline
        Algorith from http://macs.citadel.edu/chenm/343.dir/09.dir/lect3_4.pdf
        @param x 1D Array of values of independent variable
        @param y 1D Array of values of dependent variable
        @param dydx0 dy/dx at x[0]
        @param dydxf dy/dx at x[-1]
        @return a Array of spline coefficients: constant coefficient
        @return b Array of spline coefficients: linear coefficient
        @return c Array of spline coefficients: quadratic coefficient
        @return d Array of spline coefficients: cubic coefficient
        """

        # the step sizes
        np1 = len(x) # number of knots
        n = np1 - 1 # number of spline regions
        h = np.empty(n)
        oneByH = np.empty(n)
        dy = np.empty(n)
        
        for i in range(n):
            h[i] = x[i+1]-x[i]
            oneByH[i] = 1.0 / h[i]
            dy[i] = y[i+1]-y[i]
        
        # the coefficient arrays
        a = y
        b = np.empty(n)
        d = np.empty(n)

        # the right-hand side vector
        v = np.empty(np1)
        v[0] = oneByH[0] * dy[0] - dydx0
        for i in range(1, n):
            v[i] = oneByH[i] * dy[i] - oneByH[i-1] * dy[i-1]
        v[n] = dydxf - oneByH[-1] * dy[-1]
        v = 3.0 * v

        # create the tridiagonal system matrix
        # only need to create the diagonal terms; the others are just the step sizes, which are already contained in h
        bThomas = np.empty(np1)

        bThomas[0] = 2.0 * h[0]
        for i in range(1,n):
            bThomas[i] = 2.0 * (h[i-1] + h[i])
        bThomas[n] = 2.0 * h[n-1]

        # use Thomas Algorithm to solve the tridiagonal system
        c = self.ThomasAlgorithm(h, bThomas, h, v)

        # calculate the b and d coefficients
        for i in range(n):
            b[i] = oneByH[i] * (a[i+1] - a[i]) - (h[i] / 3.0) * (2.0 * c[i] + c[i+1])
            d[i] = (1.0 / 3.0) * oneByH[i] * (c[i+1] - c[i])

        return a[0:n], b, c[0:n], d

    def ThomasAlgorithm(self, a, b, c, d):
        """
        Use Thomas Algorithm to solve a tridiagonal system
        https://stackoverflow.com/questions/8733015/tridiagonal-matrix-algorithm-tdma-aka-thomas-algorithm-using-python-with-nump
        @param a Vector of coefficients below the diagonal (length n-1)
        @param b Vector of coefficients on the diagonal (length n)
        @param c Vector of coefficients above the diagonal (length n-1)
        @param d Righthand side vector (length n)
        @return p Solution vector (length n)
        """
        n = len(d)
        w = np.empty(n-1)
        g = np.empty(n)
        p = np.empty(n)

        w[0] = c[0] / b[0]
        g[0] = d[0] / b[0]

        for i in range(1,n-1):
            w[i] = c[i] / (b[i] - a[i-1] * w[i-1])
        for i in range(1,n):
            g[i] = (d[i] - a[i-1]*g[i-1]) / (b[i] - a[i-1] * w[i-1])
        p[n-1] = g[n-1]
        for i in range(n-1,0,-1):
            p[i-1] = g[i-1] - w[i-1] * p[i]

        return p

    def FiniteDifferenceAtEdge(self, xarray, yarray, leftOrRightEdge):
        """
        Use a fourth-order, single-sided numerical difference scheme to approximate
        a derivative. Mostly used so that we can use a clamped cubic spline.
        @param xarray Array of independent variable values; requires 5 values, including the edge value
        @param yarray Array of dependent variable values evaluates at xarray
        @param leftOrRightEdge At which edge are we calculating? 'left' for left edge, 'right' for right edge
        For left edge, the point of interest is xarray[0]; for right edge, the point of interest is xarray[-1]
        ***Currently assumes uniform spacing between elements of xarray
        ***Currently assumes xarray[i+1] > xarray[i]
        ***Coefficients from https://en.wikipedia.org/wiki/Finite_difference_coefficient
        """

        h = xarray[1] - xarray[0]
        oneByH = 1.0 / h
        coefArray = np.array([(-25.0 / 12.0), 4.0, -3.0, (4.0 / 3.0), (-1.0 / 4.0)])
        if leftOrRightEdge == 'left':
            # left edge
            dydx = np.dot(coefArray, yarray)
        elif leftOrRightEdge == 'right':
            # right edge
            coefArray = -coefArray
            dydx = np.dot(coefArray, np.flip(yarray, axis=0))

        dydx = oneByH * dydx

        return dydx


